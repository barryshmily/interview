# Java基础

## 1. String、StringBuilder 和StringBuffer区别 

String是字符串常量，对象不可修改，对它的修改实际上是在常量池中重新创建一个字符串常量。 

StringBuffer可在字符串对象上对自身进行修改，不必重新创建对象，是线程安全的类。 

StringBuilder同StringBuffer，是线程不安全的类。 

## 2. HashMap、LinkedHashMap、TreeMap、Hashtable、ConcurrentHashMap这几个的区别以及特点 

都是Map的实现类，存储key-value形式的键值对。 

HashMap是插入无序的，key值不重复，key允许为null值，线程不安全。 

LinkedHashMap是插入有序的，并且可以设置为按访问有序排列，key值不重复，key允许为null值，线程不安全。 

TreeMap是按字典序升序排序的，key值不重复，key不允许为null，线程不安全。 

Hashtable是线程安全的HashMap类，其余特点与HashMap相同。 

HashMap底层是一个散列表+链表的实现，从JDK8加入了红黑树的结构，当散列表的数据冲突形成链表，并且链表上的数据达到阈值8个时，就会将链表结构转换为红黑树结构。它的put过程是，计算key的hash值，与散列表的大小-1做与运算，计算出key值所在散列表的下标i，如果这个位置没有Entry对象，则直接放到这个位置上。如果在该位置上产生了冲突，则遍历整个链表，判断链表上是否有equals相等的key，有则直接替换。没有则将插入的key-value放置的链表的头部。 

它的扩容过程是，当散列表中的数据到达阈值时，HashMap会进行扩容操作，扩容后的大小是之前散列表大小的两倍。创建新的Entry数组后则会将以前的Entry数组转移到新的散列表中，转移的方法是遍历散列表，重新计算key的数组下标，如果产生冲突后，会通过头插法的方式插入到新的散列表中。 

LinkedHashMap其内部有两个大的数据结构，一个是和HashMap一样的数据结构数组+链表它本身就继承自HashMap，保证了Map的随机存取特性；另一个结构维护了一个双向链表，插入一个key-value除了放置到散列表上，还会添加到双向链表的尾部，保证了插入有序。LinkedHashMap因为它不仅能保证插入有序，还能访问有序，最近访问的会放置到链表尾部，这可以实现一个简单的LRU缓存，通过实现removeEldestEntry方法。 

TreeMap内部维护一个红黑树，能保证按字典序升序排列。不能插入null值。 

Hashtable是线程安全的HashMap类，但由于它是对普通方法上加锁，会将整个散列表锁住，以至于效率低下不怎么使用。get和put方法都会加锁，get方法加锁是因为resize扩容过后，Entry可能并不在以前的位置，所以需要对所有方法都加锁保证线程安全。 

ConcurrentHashMap同样是线程安全的HashMap类，不同的是它不再锁住整张表，而是使用分段锁的概念，将一个散列表分成几个段，当插入的元素在不同段的时候不必加锁也能实现线程安全，只有在同一个段上的时候才会加锁保证线程安全。 


## 3. HashSet、LinkedHashSet、TreeSet这几个的区别以及特点 

HashSet的值不能重复且乱序排列，可以存储null值。它的内部维护了一个HashMap，添加的值作为HashMap的key进行插入，所以保证了它的这些特性。 

LinkedHashSet保证了插入有序，它继承了HashSet类，通过调用HashSet的一个构造方法，创建一个LinkedHashMap对象以此通过LinkedHashMap来保证插入有序。 

TreeSet保证了字典有序排列，同TreeMap一样，继承了NavigatorMap类，维护的是一个红黑树保证有序。 

## 4. ArrayList、LinkedList、Vector集合的区别以及特点 

ArrayList底层使用数组实现，按插入排序，数据可重复，线程不安全。在JDK7中调用无参构造方法时不会为它分配大小，JDK6构造时即会分配大小。JDK7默认大小是10，之后的扩容会按1.5倍大小，右移一位（>>），通过调用Arrays.copyOf进行数据的转移。 

LinkedList底层使用链表实现，在JDK7是一个双向链表。同样按插入顺序，数据可重复，线程不安全，没有扩容问题。 

Vector可看做是一个线程安全的ArrayList，它通过在方法上加入synchronized关键字来保证线程安全，效率不高。可使用Collections.synchronizedList创建线程安全的List。 

在concurrent并发包中有ConcurrentHashMap线程安全的HashMap，却没有线程安全的List。这是由于ConcurrentHashMap通过分段锁的技术，既保证了线程安全，同时保证了编发性能。而List很难保证其并发性能，只有CopyOnWriteArrayList保证了只读的并发性能，而对于其修改操作同样需要锁住其整个List。 


## 5.Java中的IO，它们之间的区别 

Java中的IO有阻塞式IO（BIO），非阻塞式IO（NIO），以及异步IO（AIO）。 

同步阻塞式的IO客户端与服务器端的关系是一应一答的关系，其根本特性是一件事一件事的来，例如当一个线程在执行过程中依赖需要等待的资源时，这个时候线程会处于阻塞状态。大量的客户端请求到来时，采用同步阻塞式的IO会造成性能瓶颈。可以采用伪异步的方式，在服务器端接收到客户端请求时创建线程处理，此时会造成创建线程过多的问题。 

NIO解决BIO大并发性能低的问题，使用多路复用机制。对于BIO中的流，NIO对应的是Channel通道，在一个完整NIO的模型中，一共有三个部分组成：Channel、Buffer、Selector。一个客户端的请求数据对应一个Channel，无论是读还是写，都需要Channel写入Buffer，或者Buffer写入Channel。Selector就是NIO实现多路复用的基础。NIO中Selector可以使用单个线程对多个Channel进行处理，这也就是相对于BIO中伪异步方式带来的好处，一个线程就能在服务器端管理多个客户端请求，并且能达到很好的并发性能。 

在NIO中使用Selector会不断的轮询各个Channel来确定是否有数据可读，而在AIO中则是数据准备好过主动通知数据使用者。它利用了操作系统底层的API支持，Unix系统下是epoll IO，在Windows下则是IOCP模型。 

*Reactor和Proactor模式，同步采用Reactor，异步采用proactor 


## 6.final, finally, finalize 的区别？ 

final：不可变的对象引用，常量，一旦定义不可修改。 

finally：异常捕获中，无论如何都会执行，常用于处理文件流的关闭。 

finalize：GC前会调用此方法，不建议使用，它的调用依赖于何时进行GC，而何时GC是无法确定的。 

## 7. HashMap的初始化长度？负载因子是多少是什么？能容纳的最大个数？扩容机制？散列表长度的设计有什么特殊之处吗？为什么这么设计？如何确定索引位置？ 

初始化长度length=16，负载因子loadFactor=0.75，表示Map能容纳的数量，threshold 

能容纳的最大个数是长度*负载因子=16 * 0.75 = 12。 

在初始状态下，如果Map中的元素（Node）个数超过12个，此时便会进行扩容（resize），扩容后的容量是之前的两倍。 

由于HashMap的底层实现是数组，而数组无法自动扩容，此时只能采取重新定义一个新的数组，代替原来的数组。JDK8由于引入了红黑树，其扩容机制较为复杂，JDk7的扩容机制如下： 

创建双倍大小的数组； 

遍历散列表中的元素； 

使用头插法插入新的数组。 

JDK8做了优化，不再重新计算hash，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置 

此处关于HashMap的扩容机制还需深入理解 

散列表的长度必须是2的n次方，本来如果设计为素数导致的冲突要小于2的n次方这种设计，例如Hashtable的初始长度，但它扩容后不能保证还是素数。2的n次方设计主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位散列表索引位置时，也加入了高位参与运算的过程。 

取key的hashCode值、高位运算、取模运算。 

## 8. 简单介绍一下java中的泛型，泛型擦除以及相关的概念 

泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。 Java语言引入泛型的好处是安全简单。 

在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。 

泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。 

1. 泛型的类型参数只能是类类型（包括自定义类），不能是简单类型。 

2. 同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。 

3. 泛型的类型参数可以有多个。 

4. 泛型的参数类型可以使用extends语句，例如<T extends superclass>。习惯上称为“有界类型”。 

5. 泛型的参数类型还可以是通配符类型。例如Class<?> classType = Class.forName("java.lang.String"); 

## 9. 类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？ 

在Java中判断两个类是否是同一个类，不仅仅是类的全限定名称相同，还需要加载它们的类加载器相同。使用双亲委派模式，加载Object类时会始终使用启动类加载器进行加载，而不会使用自定义类加载器，如果不使用双亲委派模式的话程序会混乱不堪。 

JNDI服务打破了双亲委派模式。按照双亲委派模式，启动类加载器会加载JNDI，此时启动类加载器找到无法对各厂商具体实现，引入了ThreadContextClassLoader，父加载器会请求子加载器对其进行加载。 

## 10. 类的实例化顺序？ 

大致的顺序是，先静态方法、再构造方法，先父类后子类。 

父类静态成员和静态初始化块，按代码顺序； 

子类静态成员和静态初始化块，按代码顺序； 

父类实例成员和实例初始化块，按代码顺序； 

父类构造方法； 

子类实例成员和实例初始化块，按代码顺序； 

子类构造方法。 
